
import abc
import typing as tp
import binaryninja as bn

class SymbolFilters(abc.ABC):
    """
    Decides which symbols are worth exporting.

    Most of the business logic specific to personal naming conventions in my database
    are contained within here so they can be more easily overriden.
    """

    class CaseLabel(tp.NamedTuple):
        table_name: str
        case: str

    @abc.abstractmethod
    def as_useful_func_symbol(self, name) -> tp.Optional[str]:
        """ Determine if a data symbol is worth exporting, and if so, the name to export as. """
        raise NotImplementedError

    @abc.abstractmethod
    def as_useful_static_symbol(self, name) -> tp.Optional[str]:
        """ Determine if a data symbol is worth exporting as a static, and if so, the name to export as. """
        raise NotImplementedError

    @abc.abstractmethod
    def is_useful_struct_member(self, name: str, type: bn.Type) -> bool:
        """ Returns true if a member on a struct is worth exporting.  If it returns False,
        the member is treated as a gap. """
        raise NotImplementedError

    @abc.abstractmethod
    def as_case_label(self, name) -> tp.Optional[CaseLabel]:
        """ Determine if a data symbol describes a jumptable case.

        Case labels take priority over data symbols. """
        raise NotImplementedError

# =============================================================================
# Impl for my own DB

class ExphpSymbolFilters(SymbolFilters):
    def as_useful_func_symbol(self, name):
        # Done by binja, e.g. 'j_sub_45a83#4'
        if '#' in name:
            return False

        # these suffixes don't convey enough info for the name to be worth sharing if there's nothing else
        s = name  # keep name as the original name
        s = _strip_suffix(s, '_identical_twin')
        s = _strip_suffix(s, '_twin')
        s = _strip_suffix(s, '_sister')
        s = _strip_suffix(s, '_sibling')

        # Suffix aside, is this basically just 'sub_4023e0'?
        #
        # We check a few more prefixes because I've changed some prefixes using a script.
        for prefix in ['sub', 'leaf', 'seh', 'SEH', 'j_sub']:
            if s.startswith(prefix + '_') and _is_hex(s[len(prefix):].lstrip('_')):
                return None
        return name

    def as_useful_static_symbol(self, name):
        # Skip statics that I didn't rename.
        if any(
            name.startswith(prefix) and _is_hex(name[len(prefix):])
            for prefix in ['data_', 'jump_table_']
        ):
            return None

        if name in [
            '__dos_header', '__dos_stub', '__rich_header', '__coff_header',
            '__pe32_optional_header', '__section_headers',
        ]:
            return None

        # There's a large number of symbols autogenerated by binja for DLL functions.
        # Since they can be autogenerated, there's no point sharing them.
        if name.startswith('__import_') or name.startswith('__export_'):
            return None

        return name

    def is_useful_struct_member(self, name: str, type: bn.Type):
        # I use a plugin to fill extremely large gaps with char arrays to make the UI navigable.
        # These should be counted as gaps.
        is_gap_filler = bool(
            name and type and type.type_class == bn.TypeClass.ArrayTypeClass
            and name.startswith('_') and type.element_type.width == 1 and type.width > 64
        )
        return not is_gap_filler

    def as_case_label(self, name):
        # My naming pattern for case labels.
        for infix in ['__case_', '__cases_']:
            if infix in name:
                table_name, rest = name.split(infix)
                return SymbolFilters.CaseLabel(table_name=table_name, case=rest)

class SimpleFilters(SymbolFilters):
    """ A simple set of filters that keeps all functions, statics and fields. """
    def as_useful_func_symbol(self, name):
        return name

    def as_useful_static_symbol(self, name):
        return name

    def is_useful_struct_member(self, name: str, type: bn.Type):
        return True

    def as_case_label(self, name):
        return None

DEFAULT_FILTERS = ExphpSymbolFilters()

# mypy only complains on abcs when you call the constructor
_make_mypy_complain_if_SimpleFilters_is_missing_a_method = SimpleFilters()

def _strip_suffix(s, suffix):
    return s[:len(s)-len(suffix)] if s.endswith(suffix) else s

def _is_hex(s):
    try:
        int('0x' + s, 16)
    except ValueError:
        return False
    return True
